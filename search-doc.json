[{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. 提示 Use the power of React to create interactive blog posts. &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":""},{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/blog/first-blog-post","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":""},{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"Tutorial Intro","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":""},{"title":"Getting Started​","type":1,"pageTitle":"Tutorial Intro","url":"/docs/intro#getting-started","content":"Get started by creating a new site. Or try Docusaurus immediately with docusaurus.new. "},{"title":"What you'll need​","type":1,"pageTitle":"Tutorial Intro","url":"/docs/intro#what-youll-need","content":"Node.js version 16.14 or above: When installing Node.js, you are recommended to check all checkboxes related to dependencies. "},{"title":"Generate a new site​","type":1,"pageTitle":"Tutorial Intro","url":"/docs/intro#generate-a-new-site","content":"Generate a new Docusaurus site using the classic template. The classic template will automatically be added to your project after you run the command: npm init docusaurus@latest my-website classic  You can type this command into Command Prompt, Powershell, Terminal, or any other integrated terminal of your code editor. The command also installs all necessary dependencies you need to run Docusaurus. "},{"title":"Start your site​","type":1,"pageTitle":"Tutorial Intro","url":"/docs/intro#start-your-site","content":"Run the development server: cd my-website npm run start  The cd command changes the directory you're working with. In order to work with your newly created Docusaurus site, you'll need to navigate the terminal there. The npm run start command builds your website locally and serves it through a development server, ready for you to view at http://localhost:3000/. Open docs/intro.md (this page) and edit some lines: the site reloads automatically and displays your changes. "},{"title":"初识 TS","type":0,"sectionRef":"#","url":"/docs/TS-basics/初识ts","content":"","keywords":""},{"title":"变量的声明​","type":1,"pageTitle":"初识 TS","url":"/docs/TS-basics/初识ts#变量的声明","content":"let message: string = 'hello world';  string 类型 是 ts 给我们定业标识符时,提供的字符串类型 String 类型 是 js 的包装类, 是 ECMAScript 中定义的一个类  完整的声明格式 声明了类型后的 ts 就会进行类型监测, 声明的类型可以称之为类型注解 var / let / const 标识符: 数据类型 = 赋值; "},{"title":"类型注解​","type":1,"pageTitle":"初识 TS","url":"/docs/TS-basics/初识ts#类型注解","content":"let name: string = 'qwe'; const grade: number = 1; const isVIP: boolean = true;  "},{"title":"类型推导​","type":1,"pageTitle":"初识 TS","url":"/docs/TS-basics/初识ts#类型推导","content":" 声明一个标识符时,如果直接进行赋值,会根据赋值的类型推导出标识符的类型注解 let height = 1.7; // number 类型 const height = 1.7; // 字面量类型  let 进行类型推导,推导出来的是通用类型, const 推导出来的是字面量类型 在开发中,有时候为了方便起见我们并不会在声明每个变量时都写上对应的数据类型,我们更希望可以通过 ts 本身的特性帮助我们推导出对应的变量类型 "},{"title":"js 和 ts 的数据类型​","type":1,"pageTitle":"初识 TS","url":"/docs/TS-basics/初识ts#js-和-ts-的数据类型","content":"number 数字类型是开发经常使用的类型,ts 和 js 是一样的,不区分整数类型(int)和浮点数(double),统一为 number 类型 ts 和 js 一样也支持二进制,八进制,十六进制的表示 num = 100 // 10 num = 0b110 // 2 num = 0o555 // 8 num = 0xf2x // 16 boolean 布尔类型只有两个取指, true 和 false let flag: boolean = true; flag = false; flag = 20 &lt; 30; string 类型是字符串类型,可以使用双/单引号 let message: string = 'qwe'; message = 'hello ts'; 同时也支持 es6 的模板字符串来拼接变量和字符串 const name = 'qwe'; const grade = 18; const info = `my name is ${name}, grade is ${grade}`; Array 明确的指定类型注解 string[] 表示数组类型,并且数组中存放的是字符串类型, 不能往这个数组中添加其他类型的元素, (在开发中,数组一般存放相同的类型,不要存放不同的类型) let names: string[] = ['qwe', 'ewq']; Array&lt;泛型&gt; object object 对象类型可以用于描述一个对象 let info = { name: 'qwe', grade: 1, }; // === let info: { name: string, grade: number, } = { name: 'qwe', grade: 1, }; 如果我们设置了 object, 我们不能从 info 中获取数据,也不能设置数据null和undefined是两个基本数据类型, 在 ts 中,它们各种的类型也是 undefined 和 null, 意味着它们即是实际的值,也是自己的类型 "},{"title":"函数的参数类型​","type":1,"pageTitle":"初识 TS","url":"/docs/TS-basics/初识ts#函数的参数类型","content":"函数的参数是不能推导出来的,因为调用方式的不同,只能明确的 指定参数的类型,返回值是可以被推导出来的 function sum(num1: number, num2: number): number { return num1 + num2; } sum(1, 2);  "},{"title":"函数参数的类型练习​","type":1,"pageTitle":"初识 TS","url":"/docs/TS-basics/初识ts#函数参数的类型练习","content":"type LyricType = { time: number, text: string, }; function parseLyric(lyric: string) { const lyrics: LyricType[] = []; lyrics.push({ time: 111, text: '歌词' }); return lyrics; } const lyricInfos = parseLyric('qweqweqweq'); for (const item of lyricInfos) { console.log(item.time, item.text); }  匿名函数的参数​ 匿名函数的参数最好不要添加类型注解 names.forEach(function (item, index, arr) {});  TS 根据上下文可以推导出参数的类型注解, TS 根据 foreach 函数的类型以及数组的类型推断出 item 的类型,这个过程称之为上下文类型(contextual typing), 因为函数执行的上下文可以帮助确定参数和返回值的类型 "},{"title":"对象类型​","type":1,"pageTitle":"初识 TS","url":"/docs/TS-basics/初识ts#对象类型","content":"对象类型和函数类型结合使用 type PointType = { x: number, y: number }; function printInfo(point: PointType) { console.log(point.x, point.y); } printInfo({ x: 100, y: 10, });  在这里我们使用了一个对象来作为类型: 在对象我们可以添加属性,并且告知 TS 该属性需要是什么类型属性之间可以使用 ,或者;来分隔每个属性的类型部分也是可选的,如果不指定,那么就是 any 类型 可选类型​ type PointType = { x: number, y: number, z?: number };  "},{"title":"TS 中的模块化","type":0,"sectionRef":"#","url":"/docs/TS-basics/ts中的模块化","content":"","keywords":""},{"title":"内置类型导入​","type":1,"pageTitle":"TS 中的模块化","url":"/docs/TS-basics/ts中的模块化#内置类型导入","content":"TS 4.5 允许单独的导入, 你需要使用 type 前缀, 表明被导入的是一个类型 import type { IDType, IPerson } from './utils/types'; const id: IDType = 100; const foo: IFoo = { name: 'qwe', grade: 1, };  这些可以让非 TS 编译器, 比如 babel / swc 或者 esbuild 知道什么样的导入可以被安全移出 "},{"title":"命名空间 namesapce​","type":1,"pageTitle":"TS 中的模块化","url":"/docs/TS-basics/ts中的模块化#命名空间-namesapce","content":"TS 有它自己的模块格式, 名为 namespace,它在 ES 模块标准之前出现 已经基本废弃了 export namespace Time { export function format(time: string) { return '2023-5-30'; } export const name = 'time'; }  "},{"title":"类型的查找​","type":1,"pageTitle":"TS 中的模块化","url":"/docs/TS-basics/ts中的模块化#类型的查找","content":"在这之前所有的 TS 中的类型,几乎都是我们自己编写的,但是我们也有用到其他的类型 const imageEl = document.getElementById('image') as HTMLImageElement  HTMLImageElement 类型是来自那里? 为什么 document 可以有 getElementById 的方法? 这里其实涉及到了 TS 对类型的管理和查找规则 先介绍一种 TS 文件: *.d.ts 我们之前编写的 TS 文件都是 .ts 文件, 这些文件最终都会输出 .js 文件还有另一种文件 .d.ts 文件, 它是用来做类型的声明 (declare), 称之为 类型声明 或者 类型定义 文件它仅仅用来做类型监测, 告知 TS 我们有哪些类型 那么 TS 会在哪里查找我们的类型声明呢? 内置类型声明外部定义类型声明自己定义类型声明 "},{"title":"内置声明环境​","type":1,"pageTitle":"TS 中的模块化","url":"/docs/TS-basics/ts中的模块化#内置声明环境","content":"我们可以通过 target 和 lib 来决定哪些内置类型声明是可以使用的 "},{"title":"外部定义类型声明​","type":1,"pageTitle":"TS 中的模块化","url":"/docs/TS-basics/ts中的模块化#外部定义类型声明","content":"使用第三方库,需要一些类型声明 这些库通常有两种类型声明方式: 在自己库中进行类型声明 (编写 .d.ts文件) 通过社区的一个公有库 DefinitelyTyped 存放类型声明文件 自己没有声明,DefinitelyTyped库中也没有,只能手写自定义声明文件 我们在使用第三方库是一个纯 js 库,没有对应的声明文件, 比如 loadsh我们给自己的代码中声明一些类型,方便在其他地方进行使用 declare module 'lodash' { export function join(...args: any[]): any; }  // 声明模块,lodash模块默认不能使用的情况,可以自己声明一个模块 declare module 'lodash' { export function join(...args: any[]): any; } declare module 'lodash-es' { export function join(...args: any[]): any; } // 声明文件模块 declare module '*.png'; declare module '*.jpeg'; declare module '*.webp'; // vue declare module '*.vue' { import { DefineComponent } from 'vue'; const component: DefineComponent; export default component; } // cdn declare namespace $ { export function ajax(settings: any): any; }  "},{"title":"Congratulations!","type":0,"sectionRef":"#","url":"/docs/tutorial-basics/congratulations","content":"","keywords":""},{"title":"What's next?​","type":1,"pageTitle":"Congratulations!","url":"/docs/tutorial-basics/congratulations#whats-next","content":"Read the official documentationModify your site configuration with docusaurus.config.jsAdd navbar and footer items with themeConfigAdd a custom Design and LayoutAdd a search barFind inspirations in the Docusaurus showcaseGet involved in the Docusaurus Community "},{"title":"Create a Blog Post","type":0,"sectionRef":"#","url":"/docs/tutorial-basics/create-a-blog-post","content":"","keywords":""},{"title":"Create your first Post​","type":1,"pageTitle":"Create a Blog Post","url":"/docs/tutorial-basics/create-a-blog-post#create-your-first-post","content":"Create a file at blog/2021-02-28-greetings.md: blog/2021-02-28-greetings.md --- slug: greetings title: Greetings! authors: - name: Joel Marcey title: Co-creator of Docusaurus 1 url: https://github.com/JoelMarcey image_url: https://github.com/JoelMarcey.png - name: Sébastien Lorber title: Docusaurus maintainer url: https://sebastienlorber.com image_url: https://github.com/slorber.png tags: [greetings] --- Congratulations, you have made your first post! Feel free to play around and edit this post as much you like.  A new blog post is now available at http://localhost:3000/blog/greetings. "},{"title":"类型体操","type":0,"sectionRef":"#","url":"/docs/TS-basics/类型体操","content":"","keywords":""},{"title":"条件类型​","type":1,"pageTitle":"类型体操","url":"/docs/TS-basics/类型体操#条件类型","content":"开发中,我们需要基于输入的值来决定输出的值,同样我们也需要基于输入的值的类型来决定输出的值的类型 条件类型 就是用来帮助我们描述输入类型和输出类型之间的关系 条件类型的写法有点类型于 JS 中的条件表达式 (condition ? trueExpression : falseExpression) SomeType extends OtherType ? TrueType : FalseType; type IDType = number | string; type ResType = number extends IDType ? true : false; // ResType true  "},{"title":"案例​","type":1,"pageTitle":"类型体操","url":"/docs/TS-basics/类型体操#案例","content":"function sum(num1: number, num2: number): number; function sum(num1: string, num2: string): string; function sum(num1: any, num2: any) { return num1 + num2; }  function sum&lt;T&gt;(num1: T, num2: T): T extends number ? number : string; function sum(num1: any, num2: any) { return num1 + num2; } let res = sum(1, 312); let res1 = sum('qwe', 'ewq');  "},{"title":"在条件类型中推断 (infer)​","type":1,"pageTitle":"类型体操","url":"/docs/TS-basics/类型体操#在条件类型中推断-infer","content":"条件类型提供了 infer 关键字, 可以从正在比较的类型中推断类型, 然后在 true 分支中引用该推断结果 我们现在有个函数类型,想要获取到一个函数的参数类型和返回值类型 type CalcFnType = (num1: number, num2: number) =&gt; number; type ReturnType&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: any[]) =&gt; infer R ? R : never; // 内置工具 type CalcReturnType0 = ReturnType&lt;CalcFnType&gt;; // number type fooReturnType0 = ReturnType&lt;typeof foo&gt;; // string type CalcReturnType = ReturnType&lt;CalcFnType&gt;; // type CalcReturnType = number type Parameters&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never; type CalcParameterType = Parameters&lt;CalcFnType&gt;; // type CalcParameterType = [num1: number, num2: number]  "},{"title":"分发条件类型​","type":1,"pageTitle":"类型体操","url":"/docs/TS-basics/类型体操#分发条件类型","content":"当我们在泛型中使用条件类型的时候, 如果传入一个联合类型,就会变成分发的 (distributive) type ToArray&lt;T&gt; = T extends any ? T[] : never; type newType = ToArray&lt;number | string&gt;; // type newType = string[] | number[]  "},{"title":"内置工具重写​","type":1,"pageTitle":"类型体操","url":"/docs/TS-basics/类型体操#内置工具重写","content":""},{"title":"Required\\<Type>​","type":1,"pageTitle":"类型体操","url":"/docs/TS-basics/类型体操#requiredtype","content":"用于构造一个 Type,下面所有的类型都为必填的类型 type MyRequired&lt;T&gt; = { [K in keyof T]-?: T[K]; }; interface IPerson { name: string; grade?: number; test?: string; } type IPersonRequired = MyRequired&lt;IPerson&gt;; /** type IPersonRequired = { name: string; grade: number; test: string; } */ type res = Required&lt;IPerson&gt;;  "},{"title":"Readonly\\<Type>​","type":1,"pageTitle":"类型体操","url":"/docs/TS-basics/类型体操#readonlytype","content":"用于构造一个 Type 内所有属性全都设置为只读类型 type MyReadonly&lt;T&gt; = { readonly [K in keyof T]: T[K]; }; interface IPerson { name: string; grade: number; test: string; } type IPersonReadonly = MyReadonly&lt;IPerson&gt;; /** type IPersonReadonly = { readonly name: string; readonly grade: number; readonly test: string; } */ type IPersonReadonly = Readonly&lt;IPerson&gt;;  "},{"title":"Record\\<Key,Type>​","type":1,"pageTitle":"类型体操","url":"/docs/TS-basics/类型体操#recordkeytype","content":"用于构造一个对象类型,它所有的 key 都是 Keys 类型,它所有的 value 都是 Type 类型 interface IPerson { name: string; grade: number; test: string; } type MyRecord&lt;K extends keyof any, T&gt; = { [P in K]: T; }; const p1: IPerson = { name: '', grade: 0, test: '', }; const p2: IPerson = { name: '', grade: 0, test: '', }; type CityType = '贵州' | '北京'; const data: MyRecord&lt;CityType, IPerson&gt; = { 贵州: p1, 北京: p2, }; const data2: Record&lt;CityType, IPerson&gt; = { 贵州: p1, 北京: p2, };  "},{"title":"Create a Page","type":0,"sectionRef":"#","url":"/docs/tutorial-basics/create-a-page","content":"","keywords":""},{"title":"Create your first React Page​","type":1,"pageTitle":"Create a Page","url":"/docs/tutorial-basics/create-a-page#create-your-first-react-page","content":"Create a file at src/pages/my-react-page.js: src/pages/my-react-page.js import React from 'react'; import Layout from '@theme/Layout'; export default function MyReactPage() { return ( &lt;Layout&gt; &lt;h1&gt;My React page&lt;/h1&gt; &lt;p&gt;This is a React page&lt;/p&gt; &lt;/Layout&gt; ); }  A new page is now available at http://localhost:3000/my-react-page. "},{"title":"Create your first Markdown Page​","type":1,"pageTitle":"Create a Page","url":"/docs/tutorial-basics/create-a-page#create-your-first-markdown-page","content":"Create a file at src/pages/my-markdown-page.md: src/pages/my-markdown-page.md # My Markdown page This is a Markdown page  A new page is now available at http://localhost:3000/my-markdown-page. "},{"title":"Create a Document","type":0,"sectionRef":"#","url":"/docs/tutorial-basics/create-a-document","content":"","keywords":""},{"title":"Create your first Doc​","type":1,"pageTitle":"Create a Document","url":"/docs/tutorial-basics/create-a-document#create-your-first-doc","content":"Create a Markdown file at docs/hello.md: docs/hello.md # Hello This is my **first Docusaurus document**!  A new document is now available at http://localhost:3000/docs/hello. "},{"title":"Configure the Sidebar​","type":1,"pageTitle":"Create a Document","url":"/docs/tutorial-basics/create-a-document#configure-the-sidebar","content":"Docusaurus automatically creates a sidebar from the docs folder. Add metadata to customize the sidebar label and position: docs/hello.md --- sidebar_label: 'Hi!' sidebar_position: 3 --- # Hello This is my **first Docusaurus document**!  It is also possible to create your sidebar explicitly in sidebars.js: sidebars.js module.exports = { tutorialSidebar: [ 'intro', 'hello', { type: 'category', label: 'Tutorial', items: ['tutorial-basics/create-a-document'], }, ], };  "},{"title":"test","type":0,"sectionRef":"#","url":"/docs/tutorial-basics/test","content":"test firstsecondthird","keywords":""},{"title":"Manage Docs Versions","type":0,"sectionRef":"#","url":"/docs/tutorial-extras/manage-docs-versions","content":"","keywords":""},{"title":"Create a docs version​","type":1,"pageTitle":"Manage Docs Versions","url":"/docs/tutorial-extras/manage-docs-versions#create-a-docs-version","content":"Release a version 1.0 of your project: npm run docusaurus docs:version 1.0  The docs folder is copied into versioned_docs/version-1.0 and versions.json is created. Your docs now have 2 versions: 1.0 at http://localhost:3000/docs/ for the version 1.0 docscurrent at http://localhost:3000/docs/next/ for the upcoming, unreleased docs "},{"title":"Add a Version Dropdown​","type":1,"pageTitle":"Manage Docs Versions","url":"/docs/tutorial-extras/manage-docs-versions#add-a-version-dropdown","content":"To navigate seamlessly across versions, add a version dropdown. Modify the docusaurus.config.js file: docusaurus.config.js module.exports = { themeConfig: { navbar: { items: [ { type: 'docsVersionDropdown', }, ], }, }, };  The docs version dropdown appears in your navbar:  "},{"title":"Update an existing version​","type":1,"pageTitle":"Manage Docs Versions","url":"/docs/tutorial-extras/manage-docs-versions#update-an-existing-version","content":"It is possible to edit versioned docs in their respective folder: versioned_docs/version-1.0/hello.md updates http://localhost:3000/docs/hellodocs/hello.md updates http://localhost:3000/docs/next/hello "},{"title":"Translate your site","type":0,"sectionRef":"#","url":"/docs/tutorial-extras/translate-your-site","content":"","keywords":""},{"title":"Configure i18n​","type":1,"pageTitle":"Translate your site","url":"/docs/tutorial-extras/translate-your-site#configure-i18n","content":"Modify docusaurus.config.js to add support for the fr locale: docusaurus.config.js module.exports = { i18n: { defaultLocale: 'en', locales: ['en', 'fr'], }, };  "},{"title":"Translate a doc​","type":1,"pageTitle":"Translate your site","url":"/docs/tutorial-extras/translate-your-site#translate-a-doc","content":"Copy the docs/intro.md file to the i18n/fr folder: mkdir -p i18n/fr/docusaurus-plugin-content-docs/current/ cp docs/intro.md i18n/fr/docusaurus-plugin-content-docs/current/intro.md  Translate i18n/fr/docusaurus-plugin-content-docs/current/intro.md in French. "},{"title":"Start your localized site​","type":1,"pageTitle":"Translate your site","url":"/docs/tutorial-extras/translate-your-site#start-your-localized-site","content":"Start your site on the French locale: npm run start -- --locale fr  Your localized site is accessible at http://localhost:3000/fr/ and the Getting Started page is translated. 警告 In development, you can only use one locale at a same time. "},{"title":"Add a Locale Dropdown​","type":1,"pageTitle":"Translate your site","url":"/docs/tutorial-extras/translate-your-site#add-a-locale-dropdown","content":"To navigate seamlessly across languages, add a locale dropdown. Modify the docusaurus.config.js file: docusaurus.config.js module.exports = { themeConfig: { navbar: { items: [ { type: 'localeDropdown', }, ], }, }, };  The locale dropdown now appears in your navbar:  "},{"title":"Build your localized site​","type":1,"pageTitle":"Translate your site","url":"/docs/tutorial-extras/translate-your-site#build-your-localized-site","content":"Build your site for a specific locale: npm run build -- --locale fr  Or build your site to include all the locales at once: npm run build  "},{"title":"Deploy your site","type":0,"sectionRef":"#","url":"/docs/tutorial-basics/deploy-your-site","content":"","keywords":""},{"title":"Build your site​","type":1,"pageTitle":"Deploy your site","url":"/docs/tutorial-basics/deploy-your-site#build-your-site","content":"Build your site for production: npm run build  The static files are generated in the build folder. "},{"title":"Deploy your site​","type":1,"pageTitle":"Deploy your site","url":"/docs/tutorial-basics/deploy-your-site#deploy-your-site-1","content":"Test your production build locally: npm run serve  The build folder is now served at http://localhost:3000/. You can now deploy the build folder almost anywhere easily, for free or very small cost (read the Deployment Guide). "},{"title":"01 webpack 配置的结构逻辑","type":0,"sectionRef":"#","url":"/docs/webpack-basics/理解webpack结构逻辑","content":"","keywords":""},{"title":"结构化理解 webpack 配置项​","type":1,"pageTitle":"01 webpack 配置的结构逻辑","url":"/docs/webpack-basics/理解webpack结构逻辑#结构化理解-webpack-配置项","content":"Webpack 原生提供了上百种配置项，这些配置最终都会作用于 Webpack 打包过程的不同阶段，因此我们可以从流程角度更框架性、结构化地了解各项配置的作用。 Webpack 的打包过程非常复杂，但大致上可简化为：  输入：从文件系统读入代码文件；模块递归处理：调用 Loader 转译 Module 内容，并将结果转换为 AST，从中分析出模块依赖关系，进一步递归调用模块处理过程，直到所有依赖文件都处理完毕；后处理：所有模块递归处理完毕后开始执行后处理，包括模块合并、注入运行时、产物优化等，最终输出 Chunk 集合；输出：将 Chunk 写出到外部文件系统； 从上述打包流程角度，Webpack 配置项大体上可分为两类： 流程类：作用于打包流程某个或若干个环节，直接影响编译打包效果的配置项工具类：打包主流程之外，提供更多工程化工具的配置项 流程类配置项综述 与打包流程强相关的配置项有： 输入输出： entry：用于定义项目入口文件，Webpack 会从这些入口文件开始按图索骥找出所有项目文件；context：项目执行上下文路径；output：配置产物输出路径、名称等； 模块处理： resolve：用于配置模块路径解析规则，可用于帮助 Webpack 更精确、高效地找到指定模块module：用于配置模块加载规则，例如针对什么类型的资源需要使用哪些 Loader 进行处理externals：用于声明外部资源，Webpack 会直接忽略这部分资源，跳过这些资源的解析、打包操作 后处理： optimization：用于控制如何优化产物包体积，内置 Dead Code Elimination、Scope Hoisting、代码混淆、代码压缩等功能target：用于配置编译产物的目标运行环境，支持 web、node、electron 等值，不同值最终产物会有所差异mode：编译模式短语，支持 development、production 等值，可以理解为一种声明环境的短语 这里的重点是，Webpack 首先需要根据输入配置(entry/context) 找到项目入口文件；之后根据按模块处理(module/resolve/externals 等) 所配置的规则逐一处理模块文件，处理过程包括转译、依赖分析等；模块处理完毕后，最后再根据后处理相关配置项(optimization/target 等)合并模块资源、注入运行时依赖、优化产物结构等。 这些配置项与打包流程强相关，建议学习时多关注它们对主流程的影响，例如 entry 决定了项目入口，而 output 则决定产物最终往哪里输出；resolve 决定了怎么找到模块，而 module 决定了如何解读模块内容，等等。 工具类配置项综述 除了核心的打包功能之外，Webpack 还提供了一系列用于提升研发效率的工具，大体上可划分为： 开发效率类： watch：用于配置持续监听文件变化，持续构建devtool：用于配置产物 Sourcemap 生成规则devServer：用于配置与 HMR 强相关的开发服务器功能 性能优化类： cache：Webpack 5 之后，该项用于控制如何缓存编译过程信息与编译结果performance：用于配置当产物大小超过阈值时，如何通知开发者 日志类： stats：用于精确地控制编译过程的日志内容，在做比较细致的性能调试时非常有用infrastructureLogging：用于控制日志输出方式，例如可以通过该配置将日志输出到磁盘文件 逻辑上，每一个工具类配置都在主流程之外提供额外的工程化能力，例如 devtool 用于配置产物 Sourcemap 生成规则，与 Sourcemap 强相关；devServer 用于配置与 HMR 相关的开发服务器功能；watch 用于实现持续监听、构建。 工具类配置内聚性较强，通常一个配置项专注于解决一类工程问题，学习时建议先对配置项按其功能做个简单分类，例如上述开发效率类、性能优化类等，之后再展开研究其可选值与效果。 "},{"title":"配置综合解析​","type":1,"pageTitle":"01 webpack 配置的结构逻辑","url":"/docs/webpack-basics/理解webpack结构逻辑#配置综合解析","content":"先下载好 webpack 和 webpack-cli npm i -D webpack webpack-cli  文件结构 . ├── package.json ├── src │ └── index.js └── webpack.config.js  src/index.js 作为项目入口文件, webpack.config.js 为 Webpack 配置文件. webpack.config.js声明项目入口和产物输出路径 const path = require('path'); module.exports = { entry: './src/index.js', output: { filename: '[name].js', path: path.join(__dirname, './dist'), }, };  "},{"title":"02 Babel-Ts","type":0,"sectionRef":"#","url":"/docs/webpack-basics/Babel-Ts-EsLint构建环境","content":"","keywords":""},{"title":"使用 Babel​","type":1,"pageTitle":"02 Babel-Ts","url":"/docs/webpack-basics/Babel-Ts-EsLint构建环境#使用-babel","content":"ECMAScript 6.0(简称 ES6) 版本补充了大量提升 JavaScript 开发效率的新特性，包括 class 关键字、块级作用域、ES Module 方案、代理与反射等，使得 JavaScript 可以真正被用于编写复杂的大型应用程序，但知道现在浏览器、Node 等 JavaScript 引擎都或多或少存在兼容性问题。为此，现代 Web 开发流程中通常会引入 Babel 等转译工具。 Babel 是一个开源 JavaScript 转编译器，它能将高版本 —— 如 ES6 代码等价转译为向后兼容，能直接在旧版 JavaScript 引擎运行的低版本代码，例如： // 使用 Babel 转译前 arr.map(item =&gt; item + 1); // 转译后 arr.map(function (item) { return item + 1; });  添加依赖 npm i -D @babel/core @babel/preset-env babel-loader  添加模块处理规则 const path = require('path'); module.exports = { /** ... */ module: { rules: [ { test: /\\.js$/, use: [ { loader: 'babel-loader', // options: { // presets: ['@babel/preset-env'], // }, // 简写1, 如果loader 只有一个 // loader: 'babel-loader', // 简写2, 这种不能配置options属性 // use: ['babel-loader'], }, ], }, ], }, };  示例中，module 属性用于声明模块处理规则，module.rules 子属性则用于定义针对什么类型的文件使用哪些 Loader 处理器，上例可解读为： test: /\\.js$/：用于声明该规则的过滤条件，只有路径名命中该正则的文件才会应用这条规则，示例中的 /\\.js$/ 表示对所有 .js 后缀的文件生效use：用于声明这条规则的 Loader 处理器序列，所有命中该规则的文件都会被传入 Loader 序列做转译处理接入后，可以使用 .babelrc / babel.config.js 文件或 rule.options 属性配置 Babel 功能逻辑, 一般推荐使用 babel.config.js 来写配置 babel.config.js module.exports = { presets: ['@babel/preset-env'], };  示例中的 @babel/preset-env 是一种 Babel 预设规则集 —— Preset，这种设计能按需将一系列复杂、数量庞大的配置、插件、Polyfill 等打包成一个单一的资源包，从而简化 Babel 的应用、学习成本。Preset 是 Babel 的主要应用方式之一，社区已经针对不同应用场景打包了各种 Preset 资源，例如： 执行编译命令 npx webpack  文件目录 . ├── babel.config.js ├── package-lock.json ├── package.json ├── src │ └── index.js └── webpack.config.js  "},{"title":"使用 TypeScript​","type":1,"pageTitle":"02 Babel-Ts","url":"/docs/webpack-basics/Babel-Ts-EsLint构建环境#使用-typescript","content":"安装依赖 npm i -D typescript ts-loader  配置 Webpack const path = require('path'); module.exports = { /** ... */ module: { rules: [ { test: /\\.js$/, use: [ { loader: 'babel-loader', }, ], }, { test: /\\.ts$/, use: 'ts-loader', }, ], }, resolve: { extensions: ['.ts', '.js'], }, };  使用 module.rules 声明对所有符合 /\\.ts$/ 正则 —— 即 .ts 结尾的文件应用 ts-loader 加载器使用 resolve.extensions 声明自动解析 .ts 后缀文件，这意味着代码如 import &quot;./a.ts&quot; 可以忽略后缀声明，简化为 import &quot;./a&quot; 文件 创建 tsconfig.json 配置文件，并补充 TypeScript 配置信息 { &quot;compilerOptions&quot;: { &quot;noImplicitAny&quot;: true, &quot;moduleResolution&quot;: &quot;node&quot; } }  执行编译命令 npx webpack  注意，如果项目中已经使用 babel-loader，你也可以选择使用 @babel/preset-typescript 规则集，借助 babel-loader 完成 JavaScript 与 TypeScript 的转码工作： npm i -D @babel/preset-typescript  const path = require('path'); module.exports = { /** ... */ module: { rules: [ { test: /\\.js$|\\.ts$/, use: [ { loader: 'babel-loader', }, ], }, // { // test: /\\.ts$/, // use: 'ts-loader', // }, ], }, resolve: { extensions: ['.ts', '.js'], }, };  babel.config.js module.exports = { presets: [['@babel/preset-env'], ['@babel/preset-typescript']], };  不过，@babel/preset-typescript 只是简单完成代码转换，并未做类似 ts-loader 的类型检查工作，大家需要根据实际场景选择适当工具。 "},{"title":"Markdown Features","type":0,"sectionRef":"#","url":"/docs/tutorial-basics/markdown-features","content":"","keywords":""},{"title":"Front Matter​","type":1,"pageTitle":"Markdown Features","url":"/docs/tutorial-basics/markdown-features#front-matter","content":"Markdown documents have metadata at the top called Front Matter: my-doc.md --- id: my-doc-id title: My document title description: My document description slug: /my-custom-url --- ## Markdown heading Markdown text with [links](./hello.md)  "},{"title":"Links​","type":1,"pageTitle":"Markdown Features","url":"/docs/tutorial-basics/markdown-features#links","content":"Regular Markdown links are supported, using url paths or relative file paths. Let's see how to [Create a page](/create-a-page).  Let's see how to [Create a page](./create-a-page.md).  Result: Let's see how to Create a page. "},{"title":"Images​","type":1,"pageTitle":"Markdown Features","url":"/docs/tutorial-basics/markdown-features#images","content":"Regular Markdown images are supported. You can use absolute paths to reference images in the static directory (static/img/docusaurus.png): ![Docusaurus logo](/img/docusaurus.png)   You can reference images relative to the current file as well. This is particularly useful to colocate images close to the Markdown files using them: ![Docusaurus logo](./img/docusaurus.png)  "},{"title":"Code Blocks​","type":1,"pageTitle":"Markdown Features","url":"/docs/tutorial-basics/markdown-features#code-blocks","content":"Markdown code blocks are supported with Syntax highlighting. ```jsx title=&quot;src/components/HelloDocusaurus.js&quot; function HelloDocusaurus() { return ( &lt;h1&gt;Hello, Docusaurus!&lt;/h1&gt; ) } ```  src/components/HelloDocusaurus.js function HelloDocusaurus() { return &lt;h1&gt;Hello, Docusaurus!&lt;/h1&gt;; }  "},{"title":"Admonitions​","type":1,"pageTitle":"Markdown Features","url":"/docs/tutorial-basics/markdown-features#admonitions","content":"Docusaurus has a special syntax to create admonitions and callouts: :::tip My tip Use this awesome feature option ::: :::danger Take care This action is dangerous :::  My tip Use this awesome feature option Take care This action is dangerous "},{"title":"MDX and React Components​","type":1,"pageTitle":"Markdown Features","url":"/docs/tutorial-basics/markdown-features#mdx-and-react-components","content":"MDX can make your documentation more interactive and allows using any React components inside Markdown: export const Highlight = ({children, color}) =&gt; ( &lt;span style={{ backgroundColor: color, borderRadius: '20px', color: '#fff', padding: '10px', cursor: 'pointer', }} onClick={() =&gt; { alert(`You clicked the color ${color} with label ${children}`) }}&gt; {children} &lt;/span&gt; ); This is &lt;Highlight color=&quot;#25c2a0&quot;&gt;Docusaurus green&lt;/Highlight&gt; ! This is &lt;Highlight color=&quot;#1877F2&quot;&gt;Facebook blue&lt;/Highlight&gt; !  This is Docusaurus green ! This is Facebook blue ! "},{"title":"03-TS 中细节","type":0,"sectionRef":"#","url":"/docs/TS-basics/ts细节","content":"","keywords":""},{"title":"类型别名​","type":1,"pageTitle":"03-TS 中细节","url":"/docs/TS-basics/ts细节#类型别名","content":"当我们想要多次使用类型时,不需要重复编写多次 我们可以给对象起一个类型别名在其他地方多次使用 type IdType = number | string; function printID(id: IdType) { console.log(id); } type PointType = { x: number, y: number, z?: number }; function printCoordinate(point: PointType) { console.log(point.x); }  "},{"title":"接口的声明​","type":1,"pageTitle":"03-TS 中细节","url":"/docs/TS-basics/ts细节#接口的声明","content":"// interface 的声明 interface PointType2 { x: number; y: number; z?: number; } function printCoordinate(point: PointType2) { console.log(point.x); }  类型别名和接口非常相似,在定义对象类型的时候,你可以任意选择使用 接口的几乎所有特性都可以在 type 中使用 "},{"title":"type 和 interface 的区别​","type":1,"pageTitle":"03-TS 中细节","url":"/docs/TS-basics/ts细节#type-和-interface-的区别","content":"type 类型的使用范围更广 interface 只能声明对象 type MyNumber = number; type IDType = number | string; 在声明对象的时候 interface 可以多次声明 type 不允许两个相同名称的别名同时存在interface 可以多次声明一个接口名称interface 支持 继承 通过关键字 extends 实现继承 interface IPerson { name: string; grade: number; } interface IKun extends IPerson { hobby: string[]; } const ikun1: IKun = { name: 'kunkun', grade: 1, hobby: ['ball', 'song', 'dance'], }; interface 可以被类实现 总结, 如果是非对象类型的定义使用 type, 如果是对象类型的声明那么使用 interface "},{"title":"类型断言 as (type assertions)​","type":1,"pageTitle":"03-TS 中细节","url":"/docs/TS-basics/ts细节#类型断言-as-type-assertions","content":" TS 无法获取具体的类型消息,不知道你查找的这个 dom 元素是否是一个HTMLImageElement对象, 只能给它定义为 Element 对象, Element 对象自然不存在 src 和 alt 属性了 当你能够明确的知道, 它是能根据 .img 这个类名获取到 dom 元素,而且你也能够确定它拿到的是一个 HTMLImageElement 对象时 就可以使用 断言 as const imgEl = document.querySelector('.img') as HTMLImageElement; imgEl.src = 'xxx'; imgEl.alt = 'qqq';  断言的规则: 断言只能断言成更加具体的类型, 或者 不太具体(any / unknown)的类型 const grade: number = 1; const grade1 = grade as string; // 类型 &quot;number&quot; 到类型 &quot;string&quot; 的转换可能是错误的，因为两种类型不能充分重叠。如果这是有意的，请先将表达式转换为 &quot;unknown&quot;。  const grade: number = 1; const grade1 = grade as any const grade2 = grade1 as string  "},{"title":"非空类型断言 !​","type":1,"pageTitle":"03-TS 中细节","url":"/docs/TS-basics/ts细节#非空类型断言-","content":"非空类型断言使用的是 !, 表示可以确定某个标识符是有值的,跳过 TS 在编译阶段对它进行监测 interface IPerson { name: string; grade: number; friend?: { name: string, }; } const info: IPerson = { name: '', grade: 0, }; console.log(info.friend?.name);  当对象里面不存在 friend属性的时候,你去访问 friend里面的值的时候,会报错, 所以我们一般使用 可选链 的方式 但是使用 可选链 不能进行赋值操作  解决方案一 : 类型缩小 if (info.friend) { info.friend.name = 'qwe'; }  解决方案二 : 非空断言 等于是强制告诉 TS,我这里不为空,你可以给我赋值 危险 ⚠️ 只有确保 friend 有值的情况下,才能使用 info.friend!.name = 'qwe';  当我们编写下面的代码时,在执行 TS 的编译阶段会报错 这是因为传入的 message 有可能为 undefined,这个时候方法是不能执行的  function printMessage(message?: string) { console.log(message?.toUpperCase()); // 更推荐使用可选链 console.log(message!.toUpperCase()); } printMessage();  "},{"title":"字面量类型 literal types​","type":1,"pageTitle":"03-TS 中细节","url":"/docs/TS-basics/ts细节#字面量类型-literal-types","content":"字面量类型 一般配合联合类型来使用的 type Direction = 'left' | 'right' | 'top' | 'bottom'; function printDirection(direction: Direction) { console.log(direction); } printDirection('top');   "},{"title":"使用场景​","type":1,"pageTitle":"03-TS 中细节","url":"/docs/TS-basics/ts细节#使用场景","content":"type Methods = 'GET' | 'POST' | 'DELETE' | 'PATCH' | 'PUT'; type RequestArguments = { url: string, method: Methods, }; type RequestFn = (args: RequestArguments) =&gt; void; const request: RequestFn = args =&gt; { console.log(args.url, args.method); }; request({ url: 'http://test.com/api', method: 'GET' });  警告 info 是一个 string 类型的没有问题, 但是 method 也是一个 string 类型, TS 不一定能够判断出你是否符合 Methods 这个字面量类型, 所以会报错 info = { url: string, method: string, };   解决方案 1 使用类型断言 const info = { url: 'xxx', method: 'GET' as 'GET', }; request(info);  解决方案 2 让 info 对象类型是一个字面量类型 const info: { url: string, method: 'GET' } = { url: 'xxx', method: 'GET', }; request(info);  解决方案 3 as const const info = { url: 'xxx', method: 'GET', } as const; request(info);   as const 是 TS 进行字面量推理, 把 info 的 string 类型 转换为 字面量类型 "},{"title":"类型缩小 Type Narrowing​","type":1,"pageTitle":"03-TS 中细节","url":"/docs/TS-basics/ts细节#类型缩小-type-narrowing","content":"我们可以通过类似于 typeof xxx === 'number' 的判断语句, 来改变 TS 的执行路径 在给定的执行路径中,我们可以 缩小比声明时更小的类型, 这个过程称之为 缩小 (Narrowing) 而我们编写的语句 typeof xxx === 'number' 可以称之为 类型保护(type guards) "},{"title":"常见的类型保护有如下几种​","type":1,"pageTitle":"03-TS 中细节","url":"/docs/TS-basics/ts细节#常见的类型保护有如下几种","content":"typeof=== / !== (平等缩小, 可以使用 switch 或者相等的一些运算符来表达相等性)instanceofin "},{"title":"使用​","type":1,"pageTitle":"03-TS 中细节","url":"/docs/TS-basics/ts细节#使用","content":"typeof function printID(id: number | string) { if (typeof id === 'string') { console.log(id.toUpperCase()); // 在这个结构体中 TS 可以确定 id 一定为 string } else { console.log(id.toFixed(1)); // 在这个结构体中 TS 可以确定 id 一定为 number } }  === / !== 平等缩小 type Direction = 'left' | 'right' | 'center'; function turnDirection(direction: Direction) { switch (direction) { case 'left': console.log('left'); break; case 'right': console.log('right'); break; case 'center': console.log('center'); break; default: const never: never = direction; } } turnDirection('right');  instanceof function printDate(date: string | Date) { if (date instanceof Date) { console.log(date.getTime()); } else if (typeof date === 'string') { console.log(date.toUpperCase()); } }  in interface ISwim { swim: () =&gt; void; } interface IRun { run: () =&gt; void; } function move(animal: ISwim | IRun) { if ('swim' in animal) { animal.swim(); } else if ('run' in animal) { animal.run(); } } const fish: ISwim = { swim() {}, }; const dog: IRun = { run() {}, }; const test = { run1() {}, }; move(dog); move(fish); move(test); // error 类型“{ run1(): void; }”的参数不能赋给类型“ISwim | IRun”的参数。  "},{"title":"TS 中的泛型","type":0,"sectionRef":"#","url":"/docs/TS-basics/ts中的泛型","content":"","keywords":""},{"title":"泛型的基本使用​","type":1,"pageTitle":"TS 中的泛型","url":"/docs/TS-basics/ts中的泛型#泛型的基本使用","content":"认识泛型,就是广泛的类型. 参数的类型的是固定的,不够灵活 function foo(name: string, grade: number) {} foo('qwe', 1); foo('ewq', 2);  解决方法 1 any function foo(arg) { return arg; } let res0 = foo(123); // any let res1 = foo(`123`); // any let res2 = foo({ name: 'qwe' }); // any  解决方法 2 联合类型 function foo(arg: number | string | { name: string }) { return arg; } let res0 = foo(123); // number | string | { name: string }; let res1 = foo(`123`); // number | string | { name: string }; let res2 = foo({ name: 'qwe' }); // number | string | { name: string };  解决方法 3 函数重载 function foo(arg: number): number; function foo(arg: string): string; function foo(arg: { name: string }): { name: string }; function foo(arg: any) { return arg; } let res0 = foo(123); // number let res1 = foo(`123`); // string let res2 = foo({ name: 'qwe' }); // { name: 'qwe' }  "},{"title":"函数的参数化​","type":1,"pageTitle":"TS 中的泛型","url":"/docs/TS-basics/ts中的泛型#函数的参数化","content":"上面的方法都比较复杂 使用泛型, 把类型参数化 function foo&lt;Type&gt;(arg: Type): Type { return arg; } let res0 = foo &lt; number &gt; 123; // number let res1 = foo &lt; string &gt; `123`; // string let res2 = foo &lt; { name: string } &gt; { name: 'qwe' }; // { name: 'qwe' }  省略写法 TS 能根据参数推导出类型 let res1 = foo('qqq'); // string let res2 = foo(111); // number  "},{"title":"useState​","type":1,"pageTitle":"TS 中的泛型","url":"/docs/TS-basics/ts中的泛型#usestate","content":"function useState&lt;Type&gt;(initialState: Type): [Type, (newState: Type) =&gt; void] { let state = initialState; function setState(newState: Type) { state = newState; } return [state, setState]; } const [count, setCount] = useState(100); // number , (newState:number)=&gt;void const [message, setMessage] = useState('qwe'); // string , (newState:string)=&gt;void const [info, setInfo] = useState([1, 2, 3]); // number[] , (newState:number[])=&gt;void const [arr, setArr] = useState([]); // never[] , (newState:never[])=&gt;void const [arr, setArr] = useState&lt;any[]&gt;([]); // any[] , (newState:any[])=&gt;void  "},{"title":"泛型内传入多个类型​","type":1,"pageTitle":"TS 中的泛型","url":"/docs/TS-basics/ts中的泛型#泛型内传入多个类型","content":"function foo&lt;Type, Element&gt;(arg1: Type, arg2: Element) { return { arg1, arg2, }; } let res = foo(1, 'qwe'); foo(true, { name: 'qwe' });  "},{"title":"泛型接口的使用​","type":1,"pageTitle":"TS 中的泛型","url":"/docs/TS-basics/ts中的泛型#泛型接口的使用","content":"interface IKun&lt;T&gt; { name: string; grade: T; slogan: string; } const kun: IKun&lt;number | string&gt; = { name: '', grade: 1, slogan: '', };  泛型接口的默认值 interface IKunDefault&lt;T = number&gt; { name: string; grade: T; slogan: string; } const kun1: IKunDefault = { name: '', grade: 1, slogan: '', };  "},{"title":"泛型类的使用​","type":1,"pageTitle":"TS 中的泛型","url":"/docs/TS-basics/ts中的泛型#泛型类的使用","content":"class Point&lt;T = number&gt; { // x: T; // y: T; // constructor(x: T, y: T) { // this.x = x; // this.y = y; // } constructor(public x: T, public y: T) {} } const p = new Point(10, 20); const p1 = new Point('10', '20');  "},{"title":"泛型约束​","type":1,"pageTitle":"TS 中的泛型","url":"/docs/TS-basics/ts中的泛型#泛型约束","content":"interface ILength { length: number; } function getLength(arg: ILength) { return arg.length; } let res1 = getLength('123'); // number let res2 = getLength([1, 1, 1]); // number[] let res3 = getLength({ length: 100 }); // {length:number}  类型丢失 function getInfo&lt;T&gt;(arg: T) { return arg; } let res1 = getInfo('123'); // ILength let res2 = getInfo([1, 1, 1]); // number[] let res3 = getInfo({ length: 100 }); // {name:number} let res4 = getInfo(Symbol('qwe')); // symbol 没有ILength的属性,不符合我们的编码需求,但是会通过编译  泛型约束 function getInfo&lt;T extends ILength&gt;(arg: T) { return arg; } let res1 = getInfo('123'); // ILength let res2 = getInfo([1, 1, 1]); // number[] let res3 = getInfo({ length: 100 }); // {name:number} let res4 = getInfo(Symbol('qwe')); // error 类型“symbol”的参数不能赋给类型“ILength”的参数。ts(2345)  &lt;T extends ILength&gt; 表示的是传入的参数的类型必须有这个属性,也可以有其他的属性,但是至少要有这个成员 "},{"title":"使用泛型约束​","type":1,"pageTitle":"TS 中的泛型","url":"/docs/TS-basics/ts中的泛型#使用泛型约束","content":"我们希望获取一个对象给定属性名的值 我们需要确保我们不会获取 obj 上不存在的属性所以我们在两个类型之间建立一个约束 传入的 key 类型,是 object 当中 key 的其中之一 function getObjectProperty&lt;O, K extends keyof O&gt;(object: O, key: K) { return object[key]; } // === // function getObjectProperty&lt;O, K extends 'name'|'grade'|'qqq'|' // www'&gt;(object: O, key: K) { // return object[key]; // } const info = { name: 'qwe', grade: 1, qqq: 'q', www: 'w', }; const name = getObjectProperty(info, 'name'); getObjectProperty(info, 'address'); // 类型“&quot;address&quot;”的参数不能赋给类型“&quot;name&quot; | &quot;grade&quot; | &quot;qqq&quot; | &quot;www&quot;”的参数  "},{"title":"keyof​","type":1,"pageTitle":"TS 中的泛型","url":"/docs/TS-basics/ts中的泛型#keyof","content":"interface IKun { name: string; grade: number; } type IKunKeys = keyof IKun; // 'name' | 'grade'  "},{"title":"映射类型​","type":1,"pageTitle":"TS 中的泛型","url":"/docs/TS-basics/ts中的泛型#映射类型","content":"有时候,一个类型需要基于另外一个类型,但是你又不想拷贝一份,这个时候你可以考虑使用映射类型 映射类型是建立在索引签名上的语法 映射类型, 就是使用了 PropertyKeys联合类型的泛型其中 PropertyKeys 多是通过 keyof创建,然后循环遍历键名创建一个类型 type MapPerson&lt;T&gt; = { // 索引类型依次循环使用一次 [key_ in keyof T]: T[key_]; /** * name: string * grade: number */ }; interface IPerson { readonly name: string; grade?: number; } type CopyPerson = MapPerson&lt;IPerson&gt;; /** type CopyPerson = { name: string; grade: number; } */  type MapPerson&lt;T&gt; = { readonly [Property in keyof T]?: T[Property]; }; type CopyPerson = MapPerson&lt;IPerson&gt;; /** type CopyPerson = { readonly name?: string | undefined; readonly grade?: number | undefined; readonly address?: string | undefined; } */  "},{"title":"修饰符前可以加符号​","type":1,"pageTitle":"TS 中的泛型","url":"/docs/TS-basics/ts中的泛型#修饰符前可以加符号","content":"添加一个 - 号, 对被映射的类型属性修饰符进行删剪 type MapPerson&lt;T&gt; = { -readonly [Property in keyof T]-?: T[Property]; }; type CopyPerson1 = MapPerson&lt;CopyPerson&gt;; /** type CopyPerson1 = { name: string grade: number address: string } */  "},{"title":"03 预处理器-postCSS 构建 CSS","type":0,"sectionRef":"#","url":"/docs/webpack-basics/预处理器-postCSS构建CSS","content":"","keywords":""},{"title":"Webpack 如何处理 CSS 资源？​","type":1,"pageTitle":"03 预处理器-postCSS 构建 CSS","url":"/docs/webpack-basics/预处理器-postCSS构建CSS#webpack-如何处理-css-资源","content":"原生 Webpack 并不能识别 CSS 语法，假如不做额外配置直接导入 .css 文件，会导致编译失败： 为此，在 Webpack 中处理 CSS 文件，通常需要用到： css-loader：该 Loader 会将 CSS 等价翻译为形如 module.exports = &quot;${css}&quot; 的 JavaScript 代码，使得 Webpack 能够如同处理 JS 代码一样解析 CSS 内容与资源依赖；style-loader：该 Loader 将在产物中注入一系列 runtime 代码，这些代码会将 CSS 内容注入到页面的 &lt;style&gt; 标签，使得样式生效；mini-css-extract-plugin：该插件会将 CSS 代码抽离到单独的 .css 文件，并将文件通过 &lt;link&gt; 标签方式插入到页面中。 PS：当 Webpack 版本低于 5.0 时，请使用 extract-text-webpack-plugin 代替 mini-css-extract-plugin。 三种组件各司其职：css-loader 让 Webpack 能够正确理解 CSS 代码、分析资源依赖；style-loader、mini-css-extract-plugin 则通过适当方式将 CSS 插入到页面，对页面样式产生影响：  下面我们先从 css-loader 聊起，css-loader 提供了很多处理 CSS 代码的基础能力，包括 CSS 到 JS 转译、依赖解析、Sourcemap、css-in-module 等，基于这些能力，Webpack 才能像处理 JS 模块一样处理 CSS 模块代码。接入时首先需要安装依赖： npm i -D css-loader  module.exports = { /**... */ module: { rules: [ { test: /\\.js$|\\.ts$/, use: [ { loader: 'babel-loader', }, ], }, { test: /\\.css$/i, use: [ { loader: 'css-loader', }, ], }, ], }, resolve: { extensions: ['.ts', '.js'], }, };  此后，执行 npx webpack 或其它构建命令即可。经过 css-loader 处理后，样式代码最终会被转译成一段 JS 字符串：  开发环境：使用 style-loader 将样式代码注入到页面 &lt;style&gt; 标签；生产环境：使用 mini-css-extract-plugin 将样式代码抽离到单独产物文件，并以 &lt;link&gt; 标签方式引入到页面中。 经过 css-loader 处理后，CSS 代码会被转译为等价 JS 字符串，但这些字符串还不会对页面样式产生影响，需要继续接入 style-loader 加载器。 与其它 Loader 不同，style-loader 并不会对代码内容做任何修改，而是简单注入一系列运行时代码，用于将 css-loader 转译出的 JS 字符串插入到页面的 style 标签。接入时同样需要安装依赖： npm i -D style-loader  module: { rules: [ { test: /\\.css$/i, use: [ { loader: 'style-loader', }, { loader: 'css-loader', }, ], }, ],  PS：注意保持 style-loader 在前，css-loader 在后 先后再上的顺序 上述配置语义上相当于 style-loader(css-loader(css)) 链式调用，执行后样式代码会被转译为类似下面这样的代码： // Part1: css-loader 处理结果，对标到原始 CSS 代码 const __WEBPACK_DEFAULT_EXPORT__ = 'body {\\n background: orange;}'; // Part2: style-loader 处理结果，将 CSS 代码注入到 `style` 标签 injectStylesIntoStyleTag(__WEBPACK_DEFAULT_EXPORT__);  页面运行效果  经过 style-loader + css-loader 处理后，样式代码最终会被写入 Bundle 文件，并在运行时通过 style 标签注入到页面。这种将 JS、CSS 代码合并进同一个产物文件的方式有几个问题： JS、CSS 资源无法并行加载，从而降低页面性能；资源缓存粒度变大，JS、CSS 任意一种变更都会致使缓存失效。 因此，生产环境中通常会用 mini-css-extract-plugin 插件替代 style-loader，将样式代码抽离成单独的 CSS 文件。使用时，首先需要安装依赖： npm i -D mini-css-extract-plugin html-webpack-plugin  mini-css-extract-plugin 库同时提供 Loader、Plugin 组件，需要同时使用mini-css-extract-plugin 不能与 style-loader 混用，否则报错，所以上述示例中第 9 行需要判断 process.env.NODE_ENV 环境变量决定使用那个 Loadermini-css-extract-plugin 需要与 html-webpack-plugin 同时使用，才能将产物路径以 link 标签方式插入到 html 中 至此，运行 Webpack 后将同时生成 JS、CSS、HTML 三种产物文件，如： const path = require('path'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const HTMLWebpackPlugin = require('html-webpack-plugin'); module.exports = { /** ... */ module: { rules: [ /** ... */ { test: /\\.css$/i, use: [ { loader: process.env.NODE_ENV === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader, }, { loader: 'css-loader', }, ], }, ], }, plugins: [ new MiniCssExtractPlugin(), new HTMLWebpackPlugin({ title: 'webpack', template: './assets/index.html', }), ], };   "},{"title":"使用预处理器​","type":1,"pageTitle":"03 预处理器-postCSS 构建 CSS","url":"/docs/webpack-basics/预处理器-postCSS构建CSS#使用预处理器","content":"在 Webpack 中只需使用适当 Loader 即可接入预处理器，以 Less 为例，首先安装依赖： 安装依赖 npm i -D less less-loader sass sass-loader  { test: /\\.(css|less|sass|scss)$/i, use: [ { loader: process.env.NODE_ENV === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader, }, { loader: 'css-loader', }, { loader: 'sass-loader', }, { loader: 'less-loader', }, ], },  "},{"title":"使用 post-css​","type":1,"pageTitle":"03 预处理器-postCSS 构建 CSS","url":"/docs/webpack-basics/预处理器-postCSS构建CSS#使用-post-css","content":"PostCSS 能在原生 CSS 基础上增加更多表达力、可维护性、可读性更强的语言特性。两者主要区别在于预处理器通常定义了一套 CSS 之上的超集语言；PostCSS 并没有定义一门新的语言，而是与 @babel/core 类似，只是实现了一套将 CSS 源码解析为 AST 结构，并传入 PostCSS 插件做处理的流程框架，具体功能都由插件实现。 预处理器之于 CSS，就像 TypeScript 与 JavaScript 的关系；而 PostCSS 之于 CSS，则更像 Babel 与 JavaScript。 安装依赖 npm i -D postcss postcss-loader  { test: /\\.(css|less|sass|scss)$/i, use: [ { loader: process.env.NODE_ENV === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader, }, { loader: 'css-loader', }, { loader: 'postcss-loader', options: { postcssOptions: { plugins: [require('postcss-preset-env'), require('postcss-minify')], }, }, }, { loader: 'sass-loader', }, { loader: 'less-loader', }, ], },  不过，这个时候的 PostCSS 还只是个空壳，下一步还需要使用适当的 PostCSS 插件进行具体的功能处理，例如我们可以使用 autoprefixer / postcss-preset-env / postcss-minify postcss-preset-env 是 postcss 的功能集合,包含了 autoprefixer,自动添加前缀的功能,同时需要依靠 browserslist npm i -D postcss-preset-env postcss-minify  browserslist last 1 version &gt; 0.1% ie &gt;= 9  "},{"title":"TS 中的类型","type":0,"sectionRef":"#","url":"/docs/TS-basics/ts中的类型","content":"","keywords":""},{"title":"any 类型​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#any-类型","content":"在某些情况下, 我们确实 无法确定一个变量的类型,并且它可能会发生一些变化, 这个时候我们可以使用any类型 let id: any = 'aaa'; id = 'qqq'; id = 111; id = { name: 'xxx' }; const info: any[] = ['abc', 123, {}, []];  类型就表示不限制标识符的任意类型,并且可以在标识符上面进行任意的操作,any 类型有点类似于讨巧 TS 的手段 我们可以对 any 类型的变量进行任何操作, 包括获取不存在的属性 / 方法我们给一个 any 类型的变量赋值任何值, 比如数字,字符串的值 "},{"title":"unknown 类型​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#unknown-类型","content":"unknown 是 TS 中比较特殊的一种类型,它用于描述类型不确定的变量 和 any类型有点类似,但是 unknown 类型的值上做任何事情都是不合法的 let foo: any = 'qqq'; foo = 123; console.log(foo.length); let foo1: unknown = 'qqq'; foo1 = 123; console.log(foo1.length); // 类型“unknown”上不存在属性“length”。   unknown 类型默认情况下,进行任意操作都是非法的, 如果想要操作则必须进行类型缩小(校验), any则可以进行任意操作不进行校验 let foo1: unknown = 'qqq'; foo1 = 123; if (typeof foo1 === 'string') { console.log(foo1.length); // 类型缩小 }  "},{"title":"使用场景​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#使用场景","content":"const foo: () =&gt; string = () =&gt; 'foo'; const bar: () =&gt; number = () =&gt; 123; let flag: boolean = true; let result: unknown; if (flag) { result = foo(); } else { result = bar(); } if (typeof result === 'string') { console.log(result.length); }  result 要等到运行时才会知道它的类型,在真正定义它之前,我们是不知道它的类型的,我们可以使用 any,但是会存在安全隐患,这种情况下使用 unknown 类型, 并且对它进行类型缩小,以确保使用安全 "},{"title":"null 和 undefined​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#null-和-undefined","content":"TypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null，和 void 相似，它们的本身的类型用处不是很大： let a: undefined = undefined; let b: null = null; // useStrict: false // strictNullChecks: flase let n: number = 1; a = undefined;  默认情况下 null 和 undefined 是所有类型的子类型，就是说你可以把 null 和 undefined 赋值给 number 类型的变量。 但是在正式项目中一般都是开启 strictNullChecks 检测的，即 null 和 undefined 只能赋值给 any 和它们各自(一个例外是 undefined 是也可以分配给 void)，可以规避非常多的问题。 "},{"title":"void 类型​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#void-类型","content":"void 类型通常用来指定一个函数是没有返回值的,那么它的返回值就是 void function sum(num1: number, num2: number) { console.log(num1 + num2); }  这个函数我们没有写任何类型,那么它默认返回值的类型就是 void, 我们也可以显式的来指定返回值是 void function sum(num1: number, num2: number): void { console.log(num1 + num2); }  void 我们可以将 undefined 赋值给 void 类型, 也就是说一个函数不显式的 return 一个值时, js 会默认 return undefined function test(): void { return undefined; }  "},{"title":"应用场景​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#应用场景","content":"用来指定函数类型的返回值是 void 提示 一般只有我们在定义函数类型的时候我们才会使用 void, 一般不用显式的声明 void,因为 TS 会类型推导出来 type CalledType = (...args: number[]) =&gt; void; function delayExecFn(fn: CalledType) { setTimeout(() =&gt; { fn(1, 2, 3); }, 1000); } delayExecFn((a, b, c) =&gt; { console.log(a, b, c); });  "},{"title":"void 类型没有明确要求​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#void-类型没有明确要求","content":"推导出的 void 是没有明确要求也不会检查报错的 const names = ['abc', 'qwe']; names.forEach((item, index, arr) =&gt; { return 123; });   警告 显式声明 void 会校验函数返回值 function sum(num1: number, num2: number): void { console.log(num1 + num2); return 123; }   "},{"title":"Symbol​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#symbol","content":"警告 注意: 我们在使用Symbol的时候,必须添加 es6 的编译辅助库 const sym1 = Symbol('key1'); const sym2 = Symbol('key2'); Symbol('key1') === Symbol('key1'); // false  "},{"title":"never​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#never","content":"never 表示永远不会发生的值 如果一个函数中是一个死循环或者抛出一个异常,那么这个函数会返回东西吗? 不会, 那么写 void 或者其他类型作为返回值类型都不合适,我们可以使用 never 类型 开发中很少定义 never 类型开发框架(工具)的时候可能会用到 never封装一些类型工具的时候,可以使用 never function foo(): never { while (true) { console.log('----'); } } function bar(): never { throw new Error('Error'); }  提示 永远不会返回东西, 就是never "},{"title":"应用场景​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#应用场景-1","content":"function handleMessage(message: string | number | boolean) { switch (typeof message) { case 'string': console.log(message.length); break; case 'number': console.log(message); break; default: const check: never = message; // check =&gt; never } } handleMessage(111); handleMessage('111'); // 其他人调用 handleMessage(true);  在其他人扩展工具的时候,对于一些没有处理的 case,可以直接报错  "},{"title":"tuple 类型​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#tuple-类型","content":"元组类型 const info2 = { name: 'qwe', grade: 1, height: 1.7, };  元组数据结构中可以存放不同的数据类型,取出来的 item 也是有明确的类型的 const TInfo: [string, number, number] = ['qwe', 1, 1.7]; const item1 = TInfo[0]; // string const item2 = TInfo[1]; // number TInfo.forEach(i =&gt; { if (typeof i === 'string') { console.log(i.toLocaleUpperCase()); } else { console.log(i.toFixed(1)); } });  "},{"title":"元组使用场景​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#元组使用场景","content":"在函数中使用元组类型是最多的(函数的返回值) function useState(initialState: any): [number, (newValue: number) =&gt; void] { let stateValue = initialState; function setValue(newValue: any) { stateValue = newValue; } return [stateValue, setValue]; } const [count, setCount] = useState(10);  type TUseState&lt;T&gt; = [T, (newValue: T) =&gt; void]; function useState&lt;T&gt;(initialState: T): TUseState&lt;T&gt; { let stateValue = initialState; function setValue(newValue: T) { stateValue = newValue; } return [stateValue, setValue]; } const [count, setCount] = useState(10); const [state, setState] = useState('10');  "},{"title":"tuple 和 数组 有什么区别?​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#tuple-和-数组-有什么区别","content":"数组中通常建议放相同类型的元素,不同类型的元素是不推荐放在数组中的元组中每个元素都有自己特定的类型,根据索引值获取到的值可以确定对应的类型 "},{"title":"联合类型和交叉类型​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#联合类型和交叉类型","content":""},{"title":"联合类型(Union Type)​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#联合类型union-type","content":"TS 的类型系统允许我们使用多种运算符, 从 现有类型中构建新类型 联合类型是由 两个或者多个其他类型组成的类型表示 可以是这些类型中的任何一个值联合类型中的每一个类型被称之为 联合成员(union's members) let foo: number | string | boolean = 123; foo = '123'; foo = true;  "},{"title":"使用联合类型​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#使用联合类型","content":"传入一个 联合类型的值是非常简单的, 只要保证是联合类型中的某一个类型的值即可 提示 但是我们拿到这个值之后,我们应该如何使用它? 因为它可能是任意一种类型 使用缩小联合,根据缩小的代码结构,推断出更加具体的类型 function printID(ID: number | string) { if (typeof ID === 'string') { console.log(ID.toLocaleUpperCase()); } else { console.log(ID.toFixed(0)); } } printID(10); printID('111');  "},{"title":"交叉类型​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#交叉类型","content":"联合类型 用到的是或运算符号, 只是其中一个就可以了 使用符号 | let foo: number | string | boolean = 123;  foo 可以为 number / string / boolean 其中任意一个就可以 交叉类型 表示两种或者多种类型要同时满足 使用符号 &amp; type NewType = number &amp; string; // never  交叉类型 用于一个变量的时候并没有什么意义,因为一个变量不可能即是数字又是字符串, 主要是用在对象上 "},{"title":"交叉类型 的使用场景​","type":1,"pageTitle":"TS 中的类型","url":"/docs/TS-basics/ts中的类型#交叉类型-的使用场景","content":"interface IKun { name: string; grade: number; } interface ICoder extends IKun { name: string; coding: () =&gt; void; } const info: ICoder = { name: '', grade: 0, coding() {}, };  定义一个 info 对象, 使得它即满足 IKun 的接口 又满足 ICoder 的接口, 我们可以使用 extends 继承的方式来满足 但是我们可以使用更加简洁的方式去实现 就是交叉类型 interface IKun { name: string; grade: number; } interface ICoder { name: string; coding: () =&gt; void; } const info: IKun &amp; ICoder = { name: 'qwe', grade: 1, coding() { console.log('coding'); }, };  info 对象 既要满足 IKun 同时也要满足 ICoder 两个交叉起来的接口 "},{"title":"函数类型","type":0,"sectionRef":"#","url":"/docs/TS-basics/ts中的函数类型","content":"","keywords":""},{"title":"函数参数个数​","type":1,"pageTitle":"函数类型","url":"/docs/TS-basics/ts中的函数类型#函数参数个数","content":"TS 对于传入的函数类型的参数个数是不进行校验的 type CalcType = (num1: number, num2: number) =&gt; number; function calc(calcFn: CalcType) {} // 不对函数的参数进行校验 calc(function () { return 123; // 但是会校验return的参数类型 });  这是 TS 有意为之的举措, 看一个更加直观的例子 [1, 2, 3].forEach((item, i, arr) =&gt; {});  数组的 forEach 的回掉函数中的每个参数我们不一定每次都要使用,所以 TS 对回调函数的参数个数是不进行校验的 "},{"title":"调用签名 (Call Signatures)​","type":1,"pageTitle":"函数类型","url":"/docs/TS-basics/ts中的函数类型#调用签名-call-signatures","content":"在 JavaScript 中, 函数除了可以被调用,自己也是可以有属性值的 前面说的函数类型表达式, 并不能支持声明属性如果我们想描述一个带有属性的函数, 我们可以在一个对象类型中写一个 调用签名 // 函数类型表达式 type BarType = (num1: number) =&gt; number; const bar: BarType = num =&gt; num; // 函数的调用签名(从对象的角度来看待这个hans,也可以有其他属性) interface IFoo { grade: number; // 函数可以调用,函数调用签名 (num: number): number; } const foo: IFoo = num =&gt; num; foo.grade = 1; foo(123);  提示 开发中如何选择 如果只是描述函数类型本身(函数可以被调用),使用函数类型表达式如果是在描述函数作为对象可以被调用,同时业有其他属性是,使用函数签名 ::: 注意这个语法跟函数类型表达式稍有不同, 在参数列表和返回的类型之间用的是 :而不是 =&gt;::: "},{"title":"构造签名 (Construct Signatures)​","type":1,"pageTitle":"函数类型","url":"/docs/TS-basics/ts中的函数类型#构造签名-construct-signatures","content":"JavaScript 函数也可以使用 new 关键字调用, 当被调用时, TS 会认为这是一个构造 hans,因为它会产生一个新的对象 interface IPerson { new(name: string): Person; } class Person { name: string; constructor(name: string) { this.name = name; } } class Person1 { grade: number; constructor(grade: number) { this.grade = grade; } } function Factory(ctor: IPerson) { return new ctor('qwe'); } Factory(Person); Factory(Person1); // 类型“typeof Person1”的参数不能赋给类型“IPerson”的参数。 // 参数“grade”和“name” 的类型不兼容。 // 不能将类型“string”分配给类型“number”。  "},{"title":"参数的可选类型​","type":1,"pageTitle":"函数类型","url":"/docs/TS-basics/ts中的函数类型#参数的可选类型","content":"function foo(x: number, y?: number) { if (y !== undefined) { console.log(x + y); } } foo(10);  x 为必传参数, 类型为 number, y 为可选参数, 类型为 number | undefined 的联合类型可选类型需要在必传参数的后面 "},{"title":"参数的默认值​","type":1,"pageTitle":"函数类型","url":"/docs/TS-basics/ts中的函数类型#参数的默认值","content":"函数的参数可以有默认值 有默认值的情况下,参数的类型注解可以被省略有默认值的情况下,实参是可以传入 undefined 的 (JavaScript 本身也是默认传入 undefined 的) function bar(x: number, y: number = 10) { console.log(x + y); } bar(10); bar(1, undefined);  "},{"title":"剩余参数​","type":1,"pageTitle":"函数类型","url":"/docs/TS-basics/ts中的函数类型#剩余参数","content":"function sum(...nums: number[]) { let total = 0; for (const num of nums) { total += num; } return total; } sum(1, 2, 3); sum(1, 2, 3, 4, 5);  "},{"title":"函数的重载​","type":1,"pageTitle":"函数类型","url":"/docs/TS-basics/ts中的函数类型#函数的重载","content":"在 TS 中,如果我们编写了一个 add 函数,希望可以对字符串和数字类型进行相加,应该如何编写 function add(arg1: number | string, arg2: number | string) { return arg1 + arg2; // error /* 运算符“+”不能应用于类型“string | number”和“string | number”。 */ }  使用联合类型是错误的 方法 在 TS 中, 我们可以编写不同的重载签名(overload signatures) 来表示函数可以以不同的方式进行调用 一般是编写两个或者以上的重载签名,在去编写一个通用的函数实现 function add(arg1: number, arg2: number): number; function add(arg1: string, arg2: string): string; function add(arg1: any, arg2: any) { return arg1 + arg2; } add(1, 1); add('1', '2');  警告 有实现体的函数,是不能直接被调用的 "},{"title":"函数重载和联合类型​","type":1,"pageTitle":"函数类型","url":"/docs/TS-basics/ts中的函数类型#函数重载和联合类型","content":"function getLength(arg: string): number; function getLength(arg: any[]): number; function getLength(arg: any) { return arg.length; // 没有提示 } function getLength(arg: string | any[]) { return arg.length; }  两种方案都能实现,但是在可能的情况下,尽量选择使用联合类型来实现 "},{"title":"可推导的 this 类型​","type":1,"pageTitle":"函数类型","url":"/docs/TS-basics/ts中的函数类型#可推导的-this-类型","content":"在没有对 TS 进行配置的情况下,this 是 any 类型的 "},{"title":"对象中的函数 (this)​","type":1,"pageTitle":"函数类型","url":"/docs/TS-basics/ts中的函数类型#对象中的函数-this","content":"const info = { name: 'qwe', studying() { console.log(this.name); // this =&gt; any }, }; info.studying();  "},{"title":"普通函数 (this)​","type":1,"pageTitle":"函数类型","url":"/docs/TS-basics/ts中的函数类型#普通函数-this","content":"function foo() { console.log(this); // this =&gt; any }  设置了 noImplicitThis: true 后 , TS 会根据上下文推导 this,但是在不能正确推导时,就会报错,需要我们明确指定 this const info = { name: 'qwe', studying() { console.log(this.name); // this =&gt; info }, }; info.studying(); function foo() { console.log(this); // this =&gt; any // error }  如何指定 this 的类型? 函数的第一个参数我们可以根据该函数之后被调用的情况,用于声明 this 的类型(名词必须叫 this)在后续调用 hans 传入参数时,从第二个参数开始传递,this 参数会在编译之后被抹除 function foo(this: { name: string }, arg: string) { console.log(this.name, arg.split('')); // this =&gt; {name:string} } foo.call({ name: 'qqq' }, '123'); foo('123'); // error // 类型为“void”的 &quot;this&quot; 上下文不能分配给类型为“{ name: string; }”的方法的 &quot;this&quot;。  提示 foo('123'); // error // 类型为“void”的 &quot;this&quot; 上下文不能分配给类型为“{ name: string; }”的方法的 &quot;this&quot;。 这是因为 foo('123') === window.foo('123') "},{"title":"this 的内置工具​","type":1,"pageTitle":"函数类型","url":"/docs/TS-basics/ts中的函数类型#this-的内置工具","content":"ThisParameterType: 用于提取一个函数类型 Type 的 this 参数类型 如果这个函数类型没有 this 参数,返回 unknown function foo(this: { name: string }, arg: string) { console.log(this.name, arg.split('')); // this =&gt; {name:string} } type FooType = typeof foo; type FooThisType = ThisParameterType&lt;FooType&gt;; type FooThisType = { name: string, }; OmitThisParameter: 用于移除一个函数类型 Type 的 this 参数类型,并且返回当前函数的类型 type OmitType = OmitThisParameter&lt;FooType&gt;; type OmitType = (arg: string) =&gt; void; ThisType 这个类型不返回一个转换过的类型,它被用于标记一个上下文的 this, 用于绑定一个上下文的 this interface IState { name: string; grade: number; } interface IStore { state: IState; eating: () =&gt; void; running: () =&gt; void; } const store: IStore &amp; ThisType&lt;IState&gt; = { state: { name: 'qwe', grade: 1, }, eating(this: IState) { // console.log(this.state.name); console.log(this.name); }, running() { console.log(this.name); }, }; store.eating.call(store.state);  "},{"title":"条件谓词 is​","type":1,"pageTitle":"函数类型","url":"/docs/TS-basics/ts中的函数类型#条件谓词-is","content":"function isString(str: any) { return typeof str === 'string'; } function ifUpperCase(str: any) { if (isString(str)) { // str // 可以看出如果 isString 返回了 true ，那么可以知道 str 是字符串 编译器并不知道这个str的具体类型是什么, 仍然将 str 的类型 归为 any 这个广泛的类型 } }  我们可以通过 is 关键字更为精准的控制类型，以下代码相当于告诉编译器，如果返回结果为 true，则代表 str 是 string 类型 function isString(s: any): s is string { return typeof s === 'string'; } function ifUpperCase(str: any) { if (isString(str)) { str.toUpperCase(); } }  "},{"title":"类","type":0,"sectionRef":"#","url":"/docs/TS-basics/ts中的类","content":"","keywords":""},{"title":"类的使用​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#类的使用","content":"我们来定义一个类 使用 class 关键字来定义一个类 我们可以声明类的属性,在类的内部声明类的属性以及对应的类型 如果类型没有声明,那么它们默认为 any我们也可以给属性设置初始化值在默认的 strictPropertyInitialization 模式下我的们属性必须初始化,如果没有初始化,那么编译会报错 如果我们在 strictPropertyInitialization 模式下确实不希望给属性初始化,我们可以使用 xxx!:string 语法 class Person { name: string; grade = 1; constructor(name: string, grade: number) { this.name = name; this.grade = grade; } eating() { console.log(this.name); } running() { console.log(this.name); } } const p1: Person = new Person('qwe', 1); const p2: Person = new Person('qwe', 1);  "},{"title":"类的继承​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#类的继承","content":"我们使用关键字 extends来实现继承,之类中使用 super 来访问父类 class Student extends Person { sno: number; constructor(name: string, grade: number, sno: number) { super(name, grade); this.name = name; this.grade = grade; this.sno = sno; } studying() { console.log(this.name); } } new Student('qwe', 1, 1).running();  "},{"title":"类的成员修饰符​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#类的成员修饰符","content":"public 修饰的是在任何地方可见/公有的属性或者方法,默认编写的属性就是 publicprivate 修饰的是仅在同一类中可见 / 私有的属性或者方法 (类内部)protected 修饰的是仅在类自身及之类中可见 / 受保护的属性或者方法 (类内部和子类) class Person { name: string; grade: number; private test = 'test'; protected qqq = 'qqq'; constructor(name: string, grade: number) { this.name = name; this.grade = grade; } private eating() { console.log('eat', this.test, this.qqq); } } const p = new Person('qwe', 1); console.log(p.name, p.grade); class Student extends Person { constructor(name: string, grade: number, qqq: string) { super(name, grade); } studying() { console.log(this.qqq); } }  "},{"title":"只读属性​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#只读属性","content":"class Person { name: string; grade: number; private test = 'test'; protected qqq = 'qqq'; readonly www = 'www'; constructor(name: string, grade: number) { this.name = name; this.grade = grade; } private eating() { console.log('eat', this.test, this.qqq); } } const p = new Person('qwe', 1); console.log(p.name, p.grade); p.www = 'qwe'; // error 无法为“www”赋值，因为它是只读属性。  "},{"title":"getter / setter​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#getter--setter","content":"class person { #t: string; private _w: string; constructor(t: string, w: string) { this.#t = t; this._w = w; } set t(n: string) { console.log(n); this.#t = n; } get t() { console.log('this.#t:', this.#t); return this.#t; } set w(n: string) { this._w = n; } get w() { return this._w; } } const p = new person('qwe', 'ewq'); p.t = 'qwe123'; p.t;  "},{"title":"参数属性 (Parameter Properties)​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#参数属性-parameter-properties","content":"TS 提供了特殊的语法, 可以把一个构造函数参数转成一个同名同值的类属性 (参数属性) 你可以通过在构造函数参数前添加一个可见性修饰符 public / private / protected 或者是 readonly 来创建参数属性, 最后这些类属性字段也会得到这些修饰符 class Person { // test: string; name: string; grade: number; constructor(name: string, grade: number, public test: string) { this.name = name; this.grade = grade; } } const p = new Person('q', 1, 'w'); console.log(p.test);  "},{"title":"抽象类 abstract​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#抽象类-abstract","content":"继承是多态使用的前提 所以在定义很多通用的调用接口时,我们通常会让调用者传入父类,通过多态来实现更加灵活的调用方式但是, 父类本身可能并不需要对某些方法进行具体的实现,所以父类中定义的方法,我们可以定义为 抽象类 class Rectangle { constructor(public width: number, public height: number) {} getArea() { return this.width * this.height; } } class Circle { constructor(public radius: number) {} getArea() { return this.radius ** 2 * Math.PI; } } class Triangle {} function calcArea(shape: Rectangle | Circle) { return 100; } calcArea(new Rectangle(10, 20)); calcArea(new Circle(5)); calcArea(new Triangle()); // 类型“Triangle”的参数不能赋给类型“Rectangle | Circle”的参数。  一个通用的接口,随着业务的扩展,而逐步变得繁琐 abstract class Shape { // getArea 方法只有 声明没有实现体 // 实现体让之类自己实现 abstract getArea(): number; test() { return '123'; } } class Rectangle extends Shape { constructor(public width: number, public height: number) { super(); } getArea() { return this.width * this.height; } } class Circle extends Shape { constructor(public radius: number) { super(); } getArea() { return this.radius ** 2 * Math.PI; } } class Triangle extends Shape { getArea(): number { throw 100; } } function calcArea(shape: Shape) { return shape; } console.log(calcArea(new Rectangle(10, 20))); console.log(calcArea(new Circle(5))); console.log(calcArea(new Triangle())); const c = new Circle(10); c.test();  警告 抽象方法必须存在于抽象类中抽象类是使用 abstract 声明的类 特点 抽象类不能实例化抽象类可以包含抽象方法,也可以包含有实现体的方法有抽象方法的类,必须是一个抽象类抽象方法必须呗之类实现,否则该类必须是一个抽象类 "},{"title":"TS 中的类型监测(鸭子类型)​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#ts-中的类型监测鸭子类型","content":"class Person { constructor(public name: string, public grade: number) {} } class Dog { constructor(public name: string, public grade: number) {} } function printPerson(p: Person) { console.log(p.name, p.grade); } printPerson(new Person('qwe', 1)); printPerson({ name: '', grade: 1 }); printPerson(new Dog('旺财', 1)); const person: Person = new Dog('123', 1);  都没有报错 因为 TS 的类型监测时用的是鸭子类型 当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。 在鸭子类型中，关注点在于对象的行为和属性，能做什么；而不是关注对象所属的类型。它并不关心你是不是一只鸭子,只有能满足我的条件,我就认为你是一只鸭子 printPerson({ name: '', grade: 1 }); printPerson(new Dog('旺财', 1)); const person: Person = new Dog('123', 1);  TS 对这三个对象只关心是否有相对应的属性,并不关心是否是 Person 类 "},{"title":"类的类型​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#类的类型","content":"类本身也是可以作为一种数据类型的 class Person { constructor(public name: string) {} running() { console.log(this.name, 'running'); } } const p1: Person = new Person('p2'); const p2: Person = { name: 'p2', running() { console.log(this.name, 'running'); }, }; function factory(actor: new (name: string) =&gt; Person) {} factory(Person);  "},{"title":"对象类型的修饰符​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#对象类型的修饰符","content":"对象类型中的每个属性可以说明它的 类型,属性 是否可选,属性是否只读 可选属性 我们可以在属性名后面加上一个 ? 标记这个属性是可选的 只读属性 在 TS 中, 属性可以被标记为 readonly, 这不会改变任何运行时的行为, 但是了类型检查时,一个标记为 readonly 的属性是不能被写入的 type IPerson = { // ? 可选属性 name?: string; // 只读属性 readonly grade: number; }; interface IKun { name?: string; readonly slogan: string; } const p: IPerson = { name: 'qwe', grade: 0, };  "},{"title":"索引签名​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#索引签名","content":"什么是索引签名, 有的时候,你不能提前知道一个类型里所有的属性的名字,但是你知道这些值的特征, 这种情况下,你就可以用一个 索引签名 来描述可能的值 interface ICollection { length: number; } const names: string[] = ['1', '2', '3']; console.log(names[0]); console.log(names[1]); console.log(names[2]); // 通过索引访问数组 function iteratorCollection(collection: ICollection) { // collection[0]; /** 元素隐式具有 &quot;any&quot; 类型，因为类型为 &quot;0&quot; 的表达式不能用于索引类型 &quot;ICollection&quot;。 类型“ICollection”上不存在属性“0”。 */ }  添加上索引签名 索引的 key 为 number 类型,访问的值为 string 类型 要求你通过索引来访问,并且访问之后返回的数据类型为标识类型 interface ICollection { length: number; // 要求你通过索引来访问,并且访问之后返回的数据类型为标识类型 [num: number]: string; } const names: string[] = ['1', '2', '3']; console.log(names[0]); console.log(names[1]); console.log(names[2]); // 通过索引访问数组 function iteratorCollection(collection: ICollection) { collection[0]; } const tuple: [string, number] = ['qwe', 1]; iteratorCollection(tuple); // 类型“[string, number]”的参数不能赋给类型“ICollection”的参数。 // “number”索引签名不兼容。 // 不能将类型“string | number”分配给类型“string”。 // 不能将类型“number”分配给类型“string”。  interface ICollection { length: number; [index: number]: string; } const info = { name: 'qwe', grade: 1, length: 2 }; iteratorCollection(info); // 不报错  iteratorCollection({ name: 'qwe', grade: 1, length: 2 }); // error // 类型“{ name: string; grade: number; length: number; }”的参数不能赋给类型“ICollection”的参数。 // 对象字面量只能指定已知属性，并且“name”不在类型“ICollection”中。  提示 通过数字类型访问索引时,最终都是转换为 string 类型访问 interface IIndexType { [aaa: number]: any; // [bbb: string]: any; } const names: IIndexType = ['abc', 'qwe']; const names1: IIndexType = [1, 2, 3]; console.log(names['0']); console.log(names1[1]);  "},{"title":"对象类型的索引签名​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#对象类型的索引签名","content":"interface infoType { [key: string]: string; } function getInfo(): infoType { const abc: any = 'qwe'; return abc; } const info = getInfo(); let res = info.name; // res =&gt; string  interface ICollection { [index: number]: string; length: number; } function printCollection(collection: ICollection) { for (let i = 0; i &lt; collection.length; i++) { let item = collection[i]; item.split(''); // 我们一定知道每一项都是一个string类型 } } const names = ['qwe', 'ewq', 'qqq']; const tuple: [string, string] = ['111', '222']; printCollection(names); printCollection(tuple);  通过数字类型访问索引时,最终都是转换为 string 类型访问 提示 interface IIndexType { // 返回值类型的目的是告知通过索引去获取到的值是什么类型 // [xxx]:yyy // 类型只能是 string / number 不能写成联合类型 [index: string | number]: string; // error // 如果索引签名是这种的情况下 [index: string]: string; // 如果索引签名是这种的情况下 [index: number]: string; // 如果索引签名是这种的情况下 [index: string]: any; } [index: number]: string const names: IIndexType = ['abc', 'cba']; // 符合 names[0]; names['0']; [index: string]: string 索引要求必须是字符串类型 names[0] === names['0']naems 是一个 Array实例 访问值可以通过索引访问 naems[0] / naems['0'] / names['forEach'] const names: IIndexType = ['abc', 'cba']; // 不符合 names[0]; // string 符合 names['forEach']; // function 不符合 [index: string]: any const names: IIndexType = ['abc', 'cba']; // 符合 names[0]; names['0']; names['forEach'];  提示 interface IIndexType { // 两个索引类型的写法 [index: number]: string; [key: string]: any; } const names: IIndexType = ['qwe', 'ewq']; const item1 = names[0]; // item1 =&gt; string const forEach = names['forEach']; // forEach =&gt; any  "},{"title":"接口继承​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#接口继承","content":"可以从其他接口继承过来属性 减少了相同代码的重复编写如果使用了第三方库,给我们定义了一些属性,自定义了一个接口,同时你希望自定义接口拥有第三方库中某一个类型的所有属性, 可以用继承来完成 interface IPerson { name: string; grade: number; } interface IKun extends IPerson { slogan: string; } const Ikun: IKun = { slogan: '', name: '', grade: 0, };  "},{"title":"实现接口类​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#实现接口类","content":"接口定义之后,也可以被类实现 如果被一个类实现,那么在之后需要传入接口的地方,都可以将这个类传入 interface IKun { name: string; grade: number; slogan: string; playBall: () =&gt; void; } interface IRun { running: () =&gt; void; } const ikun: IKun = { name: '', grade: 0, slogan: '', playBall: function (): void { console.log('playBall'); }, }; class Person implements IKun, IRun { constructor(public name: string, public grade: number, public slogan: string) {} running() {} playBall() {} }  "},{"title":"TS 严格的字面量类型监测​","type":1,"pageTitle":"类","url":"/docs/TS-basics/ts中的类#ts-严格的字面量类型监测","content":"interface IPerson { name: string; grade: number; } const info: IPerson = { name: 'qwe', grade: 1, test: 'test', // error 对象字面量只能指定已知属性，并且“test”不在类型“IPerson”中。 };  奇怪的现象 1 interface IPerson { name: string; grade: number; } const obj = { name: 'qwe', grade: 1, test: 'test', }; const info: IPerson = obj; // 不会报错  奇怪的现象 2 function printPerson(person: IPerson) {} printPerson({ name: 'qwe', grade: 1, test: 'qwe' }); // error function printPerson(person: IPerson) {} const info2 = { name: 'qwe', grade: 1, test: 'qwe' }; printPerson(info2); // 不会报错  提示 解释现象 第一次创建的对象字面量,称之为fresh,一个新鲜的字面量 对于新鲜的字面量, 会进行严格的类型监测, 必须完全满足类型的要求 const info: IPerson = { name: 'qwe', grade: 1, test: 'test', // error }; 不新鲜了,就不会严格的监测 const obj = { name: 'qwe', grade: 1, test: 'test', }; const info: IPerson = obj;  "}]